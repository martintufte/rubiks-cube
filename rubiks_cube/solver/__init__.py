from __future__ import annotations

import logging
from typing import TYPE_CHECKING

from rubiks_cube.autotagger.pattern import get_patterns
from rubiks_cube.configuration import CUBE_SIZE
from rubiks_cube.configuration import DEFAULT_GENERATOR
from rubiks_cube.configuration.enumeration import Goal
from rubiks_cube.configuration.enumeration import SearchSide
from rubiks_cube.configuration.enumeration import SolveStrategy
from rubiks_cube.configuration.enumeration import Status
from rubiks_cube.move.generator import MoveGenerator
from rubiks_cube.representation import get_rubiks_cube_permutation
from rubiks_cube.solver.actions import get_actions
from rubiks_cube.solver.bidirectional import BidirectionalSolver
from rubiks_cube.solver.interface import SearchSummary

if TYPE_CHECKING:
    from rubiks_cube.move.algorithm import MoveAlgorithm
    from rubiks_cube.move.sequence import MoveSequence

LOGGER = logging.getLogger(__name__)


def solve_pattern(
    sequence: MoveSequence,
    goal_sequence: MoveSequence | None = None,
    generator: MoveGenerator | None = None,
    algorithms: list[MoveAlgorithm] | None = None,
    goal: Goal = Goal.solved,
    min_search_depth: int = 0,
    max_search_depth: int = 10,
    max_solutions: int = 1,
    solve_strategy: SolveStrategy = SolveStrategy.normal,
    cube_size: int = CUBE_SIZE,
    max_time: float = 60.0,
) -> SearchSummary:
    """Solve a Rubik's cube goal pattern.

    High-level functionality:

    1. Initialize:
        - Use the generator to get the action space, which is the set of all possible moves in a
        permutation. It expands the action space to include the actions that are generated by each
        sequence, if the sequence is in the list of standard moves. I.e. if the sequence is "U",
        then the action space will include "U", "U2", and "U'". The action space can also include
        algorithms, which are predefined sequences of moves.
        - Get the cube pattern for the step. This is the "colored" cube to match. The pattern
        can be seen as a way to color the facelets on the cube, and allows for solving steps such as
        orientations, permutations and CFOP steps such as cross, F2L, and the full cube.
        - Find the initial permutation by applying the sequence. If the goal sequence is provided,
        then apply the inverted goal sequence. This allows the solver to find the shortest path
        between two permutations (i.e. the matching permutation does not have to be the identity).

    2. Setup the bidirectional solver:
        - Use the actions and pattern to optimize which facelet indexes to use, removing redundant
       actions, indexes that are bijections of each other or always remains solved.
       This reduces the sizes of the permutations and the search space.
       - Use optimal data types to store the pattern, reducing memory usage.
       - Optimize the move order based on the action space.

    3. Solve:
        - Use the solver to find the shortest sequence of moves that transforms the
        initial permutation into a permutation that matches the pattern. The solver explores the
        state space from both the initial permutation under the pattern and the goal pattern
        simultaneously, meeting in the middle.

    Args:
        sequence (MoveSequence): Sequence to scramble the cube.
        goal_sequence (MoveSequence | None, optional): Sequence to scramble the goal permutation.
        generator (MoveGenerator | None, optional): Generator for actions at each step.
            Defaults to None.
        algorithms (list[MoveAlgorithm] | None, optional):
            List of algorithms to include in the action space.
        goal (Goal | None, optional): Goal to solve. Defaults to Goal.Solved.
        min_search_depth (int, optional): Minimum search depth. Defaults to 0.
        max_search_depth (int, optional): Maximum search depth. Defaults to 10.
        max_solutions (int, optional): Maximum number of solutions. Defaults to 1.
        solve_strategy (SolveStrategy, optional): Search strategy (normal, inverse, both).
            Defaults to SolveStrategy.normal.
        cube_size (int, optional): Size of the cube to solve. Defaults to CUBE_SIZE.
        max_time (float, optional): Maximum time in seconds. Defaults to 60.0.

    Returns:
        SearchSummary: Summary of the search.
    """
    if generator is None:
        generator = MoveGenerator.from_str(DEFAULT_GENERATOR)

    LOGGER.info(f"Solving with goal '{goal.name}' and strategy '{solve_strategy.value}'..")

    actions = get_actions(generator=generator, algorithms=algorithms, cube_size=cube_size)
    pattern = get_patterns(cube_size=cube_size).get(goal)
    assert pattern is not None

    optimize_indices = True
    if goal_sequence is not None:
        inverse_goal_permutation = get_rubiks_cube_permutation(
            sequence=goal_sequence,
            cube_size=cube_size,
            invert_after=True,
        )
    else:
        inverse_goal_permutation = None

    permutation = get_rubiks_cube_permutation(
        sequence=sequence,
        initial_permutation=inverse_goal_permutation,
        cube_size=cube_size,
    )

    if solve_strategy is SolveStrategy.normal:
        search_sides = [SearchSide.normal]
    elif solve_strategy is SolveStrategy.inverse:
        search_sides = [SearchSide.inverse]
    else:
        search_sides = [SearchSide.normal, SearchSide.inverse]

    all_solutions: list[MoveSequence] = []
    status = Status.Failure
    total_walltime = 0.0

    for side in search_sides:
        for variation in pattern.patterns:
            remaining_time = max_time - total_walltime
            if remaining_time <= 0:
                break

            solver = BidirectionalSolver.from_actions_and_pattern(
                actions=actions,
                pattern=variation,
                cube_size=cube_size,
                optimize_indices=optimize_indices,
                validator=pattern.validator,
            )

            pattern_summary = solver.search(
                permutation=permutation,
                max_solutions=max_solutions,
                min_search_depth=min_search_depth,
                max_search_depth=max_search_depth,
                max_time=remaining_time,
                side=side,
            )

            total_walltime += pattern_summary.walltime
            if pattern_summary.status is Status.Failure:
                continue

            status = Status.Success
            if len(pattern_summary.solutions) == 0:
                continue

            all_solutions.extend(pattern_summary.solutions)

    unique_solutions = {str(solution): solution for solution in all_solutions}
    solutions = sorted(
        unique_solutions.values(),
        key=lambda solution: (len(solution), str(solution)),
    )[:max_solutions]

    search_summary = SearchSummary(
        solutions=solutions,
        walltime=total_walltime,
        status=status,
    )

    LOGGER.info(
        f"Solver found {len(search_summary.solutions)} solutions. "
        f"Walltime: {search_summary.walltime:.2f}s"
    )

    return search_summary
