from __future__ import annotations

import logging
import time
from typing import TYPE_CHECKING

from rubiks_cube.configuration import CUBE_SIZE
from rubiks_cube.configuration.enumeration import Status
from rubiks_cube.move.generator import MoveGenerator
from rubiks_cube.move.sequence import MoveSequence
from rubiks_cube.move.sequence import measure
from rubiks_cube.move.utils import niss_move
from rubiks_cube.representation import get_rubiks_cube_state
from rubiks_cube.solver.actions import get_action_space
from rubiks_cube.solver.bidirectional_solver import bidirectional_solver as solver_fn
from rubiks_cube.solver.optimizers import IndexOptimizer
from rubiks_cube.solver.search import SearchSummary
from rubiks_cube.tag import get_rubiks_cube_pattern

if TYPE_CHECKING:
    from rubiks_cube.move.algorithm import MoveAlgorithm

LOGGER = logging.getLogger(__name__)


def solve_step(
    sequence: MoveSequence,
    generator: MoveGenerator | None = None,
    algorithms: list[MoveAlgorithm] | None = None,
    tag: str = "solved",
    subset: str | None = None,
    max_search_depth: int = 10,
    n_solutions: int = 1,
    goal_sequence: MoveSequence | None = None,
    search_inverse: bool = False,
    cube_size: int = CUBE_SIZE,
    max_time: float = 60.0,
) -> tuple[list[MoveSequence], SearchSummary]:
    """Solve a single step of the Rubik's cube.

    High-level functionality:
    1. Use the generator to get the action space, which is the set of all possible moves in a state.
       It expands the action space to include the actions that are generated by each sequence, if the
       sequence is in the list of standard moves. I.e. if the sequence is "U", then the action space
       will include "U", "U2", and "U'".
       The action space can also include algorithms, which are predefined sequences of moves.

    2. Get the pattern state for the step. This is the "colored" cube state to match. The pattern
       can be seen as a way to color the cubies on the cube, and allows for solving steps such as
       orientations, permutations and off course the full cube.

    3. Use the actions and pattern to optimize which cubie indexes to use, removing redundant
       actions, indexes that are bijections of each other or always remains solved.
       This reduces the sizes of the permutations and the search space.

    4. Find the initial state by applying the sequence. If the goal sequence is provided, then
       apply the inverted goal sequence. This allows the solver to find the shortest path between
       two states (i.e. the solved state does not have to be the solved cube). A rotation offset is
       found to adjust the permutation indexes, so that the solver works for rotated cubes.

    Args:
        sequence (MoveSequence): Sequence to scramble the cube.
        generator (MoveGenerator | None, optional): Generator for actions at each step.
            Defaults to None.
        algorithms (list[MoveAlgorithm] | None, optional):
            List of algorithms to include in the action space.
        tag (str | None, optional): Tag to solve. Defaults to None, which is the solved state.
        subset (str | None, optional): Subset of the tag. Defaults to None.
        max_search_depth (int, optional): Maximum search depth. Defaults to 10.
        n_solutions (int, optional): Number of solutions to return. Defaults to 1.
        goal_sequence (MoveSequence | None, optional): Sequence to scramble the goal state.
        search_inverse (bool, optional): Whether to search on the inverse. Defaults to False.
        cube_size (int, optional): Size of the cube to solve. Defaults to CUBE_SIZE.
        max_time (float, optional): Maximum time in seconds. Defaults to 60.0.

    Returns:
        list[MoveSequence] | None: List of solutions. None if no solution.
    """
    if generator is None:
        generator = MoveGenerator("<L, R, U, D, F, B>")

    actions = get_action_space(generator=generator, algorithms=algorithms, cube_size=cube_size)
    pattern = get_rubiks_cube_pattern(tag=tag, subset=subset, cube_size=cube_size)

    LOGGER.info(f"Solving with tag '{tag}' and subset '{subset}'.")

    if goal_sequence is not None:
        inv_goal_permutation = get_rubiks_cube_state(
            sequence=goal_sequence,
            cube_size=cube_size,
            invert_after=True,
        )
    else:
        inv_goal_permutation = None

    initial_permutation = get_rubiks_cube_state(
        sequence=sequence,
        initial_permutation=inv_goal_permutation,
        invert_after=search_inverse,
        cube_size=cube_size,
    )

    optimizer = IndexOptimizer(cube_size=cube_size)
    actions = optimizer.fit_transform(actions=actions)

    initial_permutation = optimizer.transform_permutation(initial_permutation)
    pattern = optimizer.transform_pattern(pattern)

    t = time.time()
    solutions = solver_fn(
        initial_permutation=initial_permutation,
        actions=actions,
        pattern=pattern,
        max_search_depth=max_search_depth,
        n_solutions=n_solutions,
        max_time=max_time,
    )
    walltime = time.time() - t

    n_solutions = len(solutions) if solutions is not None else 0
    status = Status.Success if solutions is not None else Status.Failure

    LOGGER.info(f"Found {n_solutions} solutions. Walltime: {walltime:.2f}s")

    search_summary = SearchSummary(
        walltime=walltime,
        n_solutions=n_solutions,
        max_search_depth=max_search_depth,
        status=status,
    )

    if solutions is None:
        return [], search_summary

    if search_inverse:
        solutions = [[niss_move(move) for move in solution] for solution in solutions]

    return sorted([MoveSequence(solution) for solution in solutions], key=measure), search_summary
