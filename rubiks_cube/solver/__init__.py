from __future__ import annotations

import logging
import time
from typing import TYPE_CHECKING

from rubiks_cube.autotagger import get_rubiks_cube_pattern
from rubiks_cube.autotagger.subset import distinguish_htr
from rubiks_cube.configuration import CUBE_SIZE
from rubiks_cube.configuration import DEFAULT_GENERATOR
from rubiks_cube.configuration.enumeration import Goal
from rubiks_cube.configuration.enumeration import Status
from rubiks_cube.move.generator import MoveGenerator
from rubiks_cube.move.sequence import MoveSequence
from rubiks_cube.move.sequence import measure
from rubiks_cube.move.utils import niss_move
from rubiks_cube.representation import get_rubiks_cube_state
from rubiks_cube.solver.actions import get_actions
from rubiks_cube.solver.bidirectional import BidirectionalSolver
from rubiks_cube.solver.interface import SearchSummary

if TYPE_CHECKING:
    from rubiks_cube.configuration.types import CubePermutation
    from rubiks_cube.configuration.types import SolutionValidator
    from rubiks_cube.move.algorithm import MoveAlgorithm

LOGGER = logging.getLogger(__name__)


def solve_pattern(
    sequence: MoveSequence,
    goal_sequence: MoveSequence | None = None,
    generator: MoveGenerator | None = None,
    algorithms: list[MoveAlgorithm] | None = None,
    goal: Goal = Goal.solved,
    subset: str | None = None,
    min_search_depth: int = 0,
    max_search_depth: int = 10,
    max_solutions: int = 1,
    search_inverse: bool = False,
    cube_size: int = CUBE_SIZE,
    max_time: float = 60.0,
) -> SearchSummary:
    """Solve a single pattern of the Rubik's cube.

    High-level functionality:

    1. Initialize:
        - Use the generator to get the action space, which is the set of all possible moves in a
        state. It expands the action space to include the actions that are generated by each
        sequence, if the sequence is in the list of standard moves. I.e. if the sequence is "U",
        then the action space will include "U", "U2", and "U'". The action space can also include
        algorithms, which are predefined sequences of moves.
        - Get the pattern state for the step. This is the "colored" cube state to match. The pattern
        can be seen as a way to color the facelets on the cube, and allows for solving steps such as
        orientations, permutations and CFOP steps such as cross, F2L, and the full cube.
        - Find the initial permutation by applying the sequence. If the goal sequence is provided,
        then apply the inverted goal sequence. This allows the solver to find the shortest path
        between two states (i.e. the solved state does not have to be the solved cube).

    2. Setup the bidirectional solver:
        - Use the actions and pattern to optimize which facelet indexes to use, removing redundant
       actions, indexes that are bijections of each other or always remains solved.
       This reduces the sizes of the permutations and the search space.
       - Use optimal data types to store the pattern, reducing memory usage.
       - Optimize the move order based on the action space.

    3. Solve:
        - Use the solver to find the shortest sequence of moves that transforms the
        initial permutation into a state that matches the pattern. The solver explores the state
        space from both the initial permutation and the goal pattern simultaneously, meeting in
        the middle.

    Args:
        sequence (MoveSequence): Sequence to scramble the cube.
        goal_sequence (MoveSequence | None, optional): Sequence to scramble the goal state.
        generator (MoveGenerator | None, optional): Generator for actions at each step.
            Defaults to None.
        algorithms (list[MoveAlgorithm] | None, optional):
            List of algorithms to include in the action space.
        goal (Goal | None, optional): Goal to solve. Defaults to Goal.Solved.
        subset (str | None, optional): Subset of the pattern. Defaults to None.
        min_search_depth (int, optional): Minimum search depth. Defaults to 0.
        max_search_depth (int, optional): Maximum search depth. Defaults to 10.
        max_solutions (int, optional): Maximum number of solutions. Defaults to 1.
        search_inverse (bool, optional): Whether to search on the inverse. Defaults to False.
        cube_size (int, optional): Size of the cube to solve. Defaults to CUBE_SIZE.
        max_time (float, optional): Maximum time in seconds. Defaults to 60.0.

    Returns:
        SearchSummary: Summary of the search.
    """
    if generator is None:
        generator = MoveGenerator.from_str(DEFAULT_GENERATOR)

    LOGGER.info(f"Solving with {goal=} and {subset=}.")

    # Setup solver
    actions = get_actions(generator=generator, algorithms=algorithms, cube_size=cube_size)
    pattern = get_rubiks_cube_pattern(goal=goal, subset=subset, cube_size=cube_size)

    optimize_indices = True
    solution_validator: SolutionValidator | None = None
    if goal == Goal.htr:
        optimize_indices = False

        def _is_real_htr(permutation: CubePermutation) -> bool:
            return distinguish_htr(permutation) == "real"

        solution_validator = _is_real_htr

    solver = BidirectionalSolver.from_actions_and_pattern(
        actions=actions,
        pattern=pattern,
        cube_size=cube_size,
        optimize_indices=optimize_indices,
        solution_validator=solution_validator,
    )

    # Determine the permutation to solve
    if goal_sequence is not None:
        inverse_goal_permutation = get_rubiks_cube_state(
            sequence=goal_sequence,
            cube_size=cube_size,
            invert_after=True,
        )
    else:
        inverse_goal_permutation = None

    permutation = get_rubiks_cube_state(
        sequence=sequence,
        initial_permutation=inverse_goal_permutation,
        invert_after=search_inverse,
        cube_size=cube_size,
    )

    # Solve the permutation with the class
    start_time = time.perf_counter()
    solutions = solver.search(
        permutation=permutation,
        max_solutions=max_solutions,
        min_search_depth=min_search_depth,
        max_search_depth=max_search_depth,
        max_time=max_time,
    )
    walltime = time.perf_counter() - start_time

    if solutions is None:
        LOGGER.info(f"Found no solutions. Walltime: {walltime:.2f}s")

        return SearchSummary(
            solutions=[],
            walltime=walltime,
            status=Status.Failure,
        )

    LOGGER.info(f"Found {len(solutions)} solutions. Walltime: {walltime:.2f}s")

    if search_inverse:
        solutions = [[niss_move(move) for move in solution] for solution in solutions]

    return SearchSummary(
        solutions=sorted([MoveSequence(solution) for solution in solutions], key=measure),
        walltime=walltime,
        status=Status.Success,
    )
