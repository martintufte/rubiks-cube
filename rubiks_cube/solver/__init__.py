from __future__ import annotations

import logging
import time
from typing import TYPE_CHECKING

import numpy as np

from rubiks_cube.configuration import CUBE_SIZE
from rubiks_cube.configuration.enumeration import Status
from rubiks_cube.formatting.regex import canonical_key
from rubiks_cube.move.generator import MoveGenerator
from rubiks_cube.move.sequence import MoveSequence
from rubiks_cube.move.sequence import measure
from rubiks_cube.move.utils import niss_move
from rubiks_cube.representation import get_rubiks_cube_state
from rubiks_cube.solver.actions import get_action_space
from rubiks_cube.solver.bidirectional.beta import bidirectional_solver as solver_fn
from rubiks_cube.solver.interface import SearchSummary
from rubiks_cube.solver.optimizers import DtypeOptimizer
from rubiks_cube.solver.optimizers import IndexOptimizer
from rubiks_cube.tag import get_rubiks_cube_pattern

if TYPE_CHECKING:
    from rubiks_cube.move.algorithm import MoveAlgorithm

LOGGER = logging.getLogger(__name__)


def solve_step(
    sequence: MoveSequence,
    generator: MoveGenerator | None = None,
    algorithms: list[MoveAlgorithm] | None = None,
    tag: str = "solved",
    subset: str | None = None,
    max_search_depth: int = 10,
    n_solutions: int = 1,
    goal_sequence: MoveSequence | None = None,
    search_inverse: bool = False,
    cube_size: int = CUBE_SIZE,
    max_time: float = 60.0,
) -> tuple[list[MoveSequence], SearchSummary]:
    """Solve a single step of the Rubik's cube.

    High-level functionality:

    1. Initialize:
        - Use the generator to get the action space, which is the set of all possible moves in a
        state. It expands the action space to include the actions that are generated by each
        sequence, if the sequence is in the list of standard moves. I.e. if the sequence is "U",
        then the action space will include "U", "U2", and "U'". The action space can also include
        algorithms, which are predefined sequences of moves.
        - Get the pattern state for the step. This is the "colored" cube state to match. The pattern
        can be seen as a way to color the facelets on the cube, and allows for solving steps such as
        orientations, permutations and CFOP steps such as cross, F2L, and the full cube.
        - Find the initial permutation by applying the sequence. If the goal sequence is provided,
        then apply the inverted goal sequence. This allows the solver to find the shortest path
        between two states (i.e. the solved state does not have to be the solved cube). A rotation
        offset is found to adjust the permutation indexes, so that the solver works for rotated
        cubes.

    2. Optimize:
        - Use the actions and pattern to optimize which facelet indexes to use, removing redundant
       actions, indexes that are bijections of each other or always remains solved.
       This reduces the sizes of the permutations and the search space.
       - Use optimal data types to store the pattern, reducing memory usage.
       - Optimize the canonical move order based on the action space.

    3. Solve:
        - Use a bidirectional solver to find the shortest sequence of moves that transforms the
        initial permutation into a state that matches the pattern. The solver explores the state
        space from both the initial permutation and the goal pattern simultaneously, meeting in
        the middle.

    Args:
        sequence (MoveSequence): Sequence to scramble the cube.
        generator (MoveGenerator | None, optional): Generator for actions at each step.
            Defaults to None.
        algorithms (list[MoveAlgorithm] | None, optional):
            List of algorithms to include in the action space.
        tag (str | None, optional): Tag to solve. Defaults to None, which is the solved state.
        subset (str | None, optional): Subset of the tag. Defaults to None.
        max_search_depth (int, optional): Maximum search depth. Defaults to 10.
        n_solutions (int, optional): Number of solutions to return. Defaults to 1.
        goal_sequence (MoveSequence | None, optional): Sequence to scramble the goal state.
        search_inverse (bool, optional): Whether to search on the inverse. Defaults to False.
        cube_size (int, optional): Size of the cube to solve. Defaults to CUBE_SIZE.
        max_time (float, optional): Maximum time in seconds. Defaults to 60.0.

    Returns:
        list[MoveSequence] | None: List of solutions. None if no solution.
    """
    if generator is None:
        generator = MoveGenerator(generator="<L, R, U, D, F, B>")

    LOGGER.info(f"Solving with tag '{tag}' and subset '{subset}'.")

    # Get action space, pattern and initial permutation
    actions = get_action_space(generator=generator, algorithms=algorithms, cube_size=cube_size)
    pattern = get_rubiks_cube_pattern(tag=tag, subset=subset, cube_size=cube_size)

    if goal_sequence is not None:
        inv_goal_permutation = get_rubiks_cube_state(
            sequence=goal_sequence,
            cube_size=cube_size,
            invert_after=True,
        )
    else:
        inv_goal_permutation = None

    initial_permutation = get_rubiks_cube_state(
        sequence=sequence,
        initial_permutation=inv_goal_permutation,
        invert_after=search_inverse,
        cube_size=cube_size,
    )

    # Optimize indices for permutation and pattern
    index_optimizer = IndexOptimizer(cube_size=cube_size)
    actions = index_optimizer.fit_transform(actions=actions)
    initial_permutation = index_optimizer.transform_permutation(initial_permutation)
    pattern = index_optimizer.transform_pattern(pattern)

    # Optimize the data type for storing pattern
    dtype_optimzier = DtypeOptimizer()
    pattern = dtype_optimzier.fit_transform(pattern)

    # Optimize canonical move order based on action space
    actions = {name: actions[name] for name in sorted(actions.keys(), key=canonical_key)}
    n_actions = len(actions)
    closed_perms: set[tuple[int, ...]] = {tuple(np.arange(pattern.size))}
    closed_perms |= {tuple(perm) for perm in actions.values()}

    canonical_matrix = np.ones((n_actions, n_actions), dtype=bool)
    for i, perm_i in enumerate(actions.values()):
        for j, perm_j in enumerate(actions.values()):
            perm_ji = tuple(perm_j[perm_i])
            if perm_ji in closed_perms or (i > j and perm_ji == tuple(perm_i[perm_j])):
                canonical_matrix[i, j] = False

    start_time = time.perf_counter()
    solutions = solver_fn(
        initial_permutation=initial_permutation,
        actions=actions,
        pattern=pattern,
        max_search_depth=max_search_depth,
        n_solutions=n_solutions,
        canonical_matrix=canonical_matrix,
        max_time=max_time,
    )
    walltime = time.perf_counter() - start_time

    n_solutions = len(solutions) if solutions is not None else 0
    status = Status.Success if solutions is not None else Status.Failure

    LOGGER.info(f"Found {n_solutions} solutions. Walltime: {walltime:.2f}s")

    search_summary = SearchSummary(
        walltime=walltime,
        n_solutions=n_solutions,
        max_search_depth=max_search_depth,
        status=status,
    )

    if solutions is None:
        return [], search_summary

    if search_inverse:
        solutions = [[niss_move(move) for move in solution] for solution in solutions]

    return sorted([MoveSequence(solution) for solution in solutions], key=measure), search_summary
