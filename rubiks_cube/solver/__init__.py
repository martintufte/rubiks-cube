from __future__ import annotations

import logging
import time

import numpy as np

from rubiks_cube.configuration import CUBE_SIZE
from rubiks_cube.move.generator import MoveGenerator
from rubiks_cube.move.sequence import MoveSequence
from rubiks_cube.solver.actions import get_action_space
from rubiks_cube.solver.bidirectional_solver import bidirectional_solver
from rubiks_cube.solver.optimizers import IndexOptimizer
from rubiks_cube.solver.optimizers import find_rotation_offset
from rubiks_cube.state import get_rubiks_cube_state
from rubiks_cube.state.pattern import get_pattern_state
from rubiks_cube.state.utils import invert

LOGGER = logging.getLogger(__name__)


def solve_step(
    sequence: MoveSequence,
    generator: MoveGenerator = MoveGenerator("<L, R, U, D, F, B>"),
    step: str | None = None,
    max_search_depth: int = 10,
    n_solutions: int = 1,
    goal_sequence: MoveSequence | None = None,
    search_inverse: bool = False,
    cube_size: int = CUBE_SIZE,
) -> list[MoveSequence] | None:
    """Solve a single step of the Rubik's cube. High level functionality:

    1. Use the generator to get the action space, which is the set of all possible moves in a state.
       It exands the action space to include the actions that are generated by each sequence, if the
       sequence is in the list of standard moves. I.e. if the sequence is "U", then the action space
       will include "U", "U2", and "U'".

    2. Get the pattern state for the step. This is the "colored" cube state to match. The pattern
       can be seen as a way to color the cubies on the cube, and allows for solving steps such as
       orientations, permutations and off course the full cube.

    3. Use the actions and pattern to optimize which cubie indexes to use, removing redundant
       actions, indexes that are bijections of each other or always remains solved.
       This reduces the sizes of the permutations and the search space.

    4. Find the initial state by applying the sequence. If the goal sequence is provided, then
       apply the goal sequence in reverse. This allows the solver to find the shortest path between
       two states (i.e. the solved state does not have to be the solved cube). A rotation offset is
       found to adjust the permutation indexes, so that the solver works for rotated cubes.

    Args:
        sequence (MoveSequence): Sequence to scramble the cube.
        generator (MoveGenerator, optional): Generator for actions at each step.
            Defaults to MoveGenerator("<L, R, U, D, F, B>").
        step (str | None, optional): Step to solve. Defaults to None, which is the solved state.
        max_search_depth (int, optional): Maximum search depth. Defaults to 10.
        n_solutions (int, optional): Number of solutions to return. Defaults to 1.
        goal_sequence (MoveSequence | None, optional): Sequence to scramble the goal state.
        search_inverse (bool, optional): Whether to search on the inverse. Defaults to False.
        cube_size (int, optional): Size of the cube to solve. Defaults to CUBE_SIZE.

    Returns:
        list[MoveSequence] | None: List of solutions. None if no solution.
    """

    # Define the action space and pattern state
    actions = get_action_space(generator=generator, cube_size=cube_size)
    pattern = get_pattern_state(step=step, cube_size=cube_size)

    optimizer = IndexOptimizer()
    actions, pattern = optimizer.fit_transform(actions=actions, pattern=pattern)

    # Find the initial state
    if goal_sequence is not None:
        goal_permutation = get_rubiks_cube_state(
            sequence=goal_sequence,
            cube_size=cube_size,
            invert_after=True,
        )
    else:
        goal_permutation = None

    initial_permutation = get_rubiks_cube_state(
        sequence=sequence,
        initial_state=goal_permutation,
        invert_after=search_inverse,
        cube_size=cube_size,
    )
    rotation_offset = find_rotation_offset(initial_permutation, optimizer.mask)
    if rotation_offset is not None:
        inv_rotation_offset = invert(rotation_offset)
        initial_permutation = inv_rotation_offset[initial_permutation]

    permutation = optimizer.transform(initial_permutation)

    # Check if the cube is already solved
    if np.array_equal(pattern[permutation], pattern):
        return []

    t = time.time()
    solutions = bidirectional_solver(
        permutation=permutation,
        actions=actions,
        pattern=pattern,
        max_search_depth=max_search_depth,
        n_solutions=n_solutions,
    )
    n_solutions = len(solutions) if solutions is not None else 0
    LOGGER.info(f"Found {n_solutions} solutions. Walltime: {time.time() - t:.2f}s")

    if solutions is not None:
        if search_inverse:
            solutions = [f"({solution})" for solution in solutions]
        return sorted([MoveSequence(solution) for solution in solutions], key=len)
    return None
